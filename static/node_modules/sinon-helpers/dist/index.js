'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _forEach = _interopDefault(require('ramda/src/forEach'));
var _filter = _interopDefault(require('ramda/src/filter'));
var _compose = _interopDefault(require('ramda/src/compose'));
var fluentArguments = require('fluent-arguments');
var sinon = _interopDefault(require('sinon'));

var getArrayFromArrayLikeObject = function getArrayFromArrayLikeObject(args) {
  return Array.prototype.slice.call(args);
};

var isMethod = function isMethod(object) {
  return function (propName) {
    return !Object.getOwnPropertyDescriptor(object, propName).get && typeof object[propName] === 'function' && !(propName === 'constructor');
  };
};

var applyToEachFunctionKeyInObject = function applyToEachFunctionKeyInObject(appliedFunction, object) {
  return _compose(_forEach(appliedFunction), _filter(isMethod(object)))(Object.getOwnPropertyNames(object));
};

var applyToEachFunctionKeyInPrototypeChain = function applyToEachFunctionKeyInPrototypeChain(appliedFunction, object) {
  if (object) {
    applyToEachFunctionKeyInObject(appliedFunction, object);
    applyToEachFunctionKeyInPrototypeChain(appliedFunction, Object.getPrototypeOf(object));
  }
};

var getInstanceIndexWithValidation = function getInstanceIndexWithValidation(index, numInstances) {
  var instanceIndex = index || 0;

  if (typeof index === 'undefined') {
    if (numInstances > 1) {
      throw new Error('Tried to access only instance of StubConstructor, ' + ('but there were ' + numInstances + ' instances.'));
    }
  }
  if (numInstances <= instanceIndex) {
    throw new Error('Tried to access StubConstructor instance ' + instanceIndex + ', ' + ('but there were only ' + numInstances + ' instances.'));
  }
  return instanceIndex;
};

var getStubOrSpyConstructor = ( /* tree-shaking no-side-effects-when-called */function (getConstructorProperties) {
  return function (Target) {
    var constructorProps = getConstructorProperties(Target);
    var instances = [];
    var instanceArgs = [];
    var methodParams = [];
    var afterCreation = void 0;

    function StubOrSpyConstructor() {
      constructorProps.SourceConstructor.apply(this, arguments);
      instanceArgs.push(getArrayFromArrayLikeObject(arguments));
      instances.push(this);

      Target && applyToEachFunctionKeyInPrototypeChain(constructorProps.processMethodOfInstance(this), constructorProps.getInstanceMethodNameSource(this));
      methodParams.forEach(constructorProps.configureMethodOfInstance(this));
      afterCreation && afterCreation(this);
    }

    StubOrSpyConstructor.prototype = constructorProps.SourceConstructor.prototype;

    StubOrSpyConstructor[constructorProps.addMethodsKey] = fluentArguments.createFunc(function (methods) {
      methodParams = methods;
      return this;
    });

    StubOrSpyConstructor.afterCreation = function (onAfterCreation) {
      afterCreation = onAfterCreation;
      return this;
    };

    StubOrSpyConstructor.getInstances = function () {
      return instances;
    };

    StubOrSpyConstructor.getInstance = function (index) {
      return instances[getInstanceIndexWithValidation(index, instances.length)];
    };

    StubOrSpyConstructor.getInstancesArgs = function () {
      return instanceArgs;
    };

    StubOrSpyConstructor.getInstanceArgs = function (index) {
      return instanceArgs[getInstanceIndexWithValidation(index, instances.length)];
    };

    Target && applyToEachFunctionKeyInObject(constructorProps.processMethodOfConstructor(StubOrSpyConstructor), Target);
    return StubOrSpyConstructor;
  };
});

var ARG_RETURN_VAL = 'returnVal';
var ARG_RETURN_THIS = 'returnThis';

var setMethodToStub = function setMethodToStub(object) {
  return function (methodName) {
    object[methodName] = sinon.stub();
  };
};

var configureStub = function configureStub(object, params) {
  if (params.hasOwnProperty(ARG_RETURN_THIS)) {
    object[params.value].returnsThis();
  } else if (params.hasOwnProperty(ARG_RETURN_VAL)) {
    object[params.value].returns(params[ARG_RETURN_VAL]);
  }
};
var setMethodToStubWithParams = function setMethodToStubWithParams(object) {
  return function (params) {
    setMethodToStub(object)(params.value);
    configureStub(object, params);
  };
};

var stubMethodWithParams = function stubMethodWithParams(object) {
  return function (params) {
    object[params.value] && object[params.value].restore && object[params.value].restore();
    sinon.stub(object, params.value);
    configureStub(object, params);
  };
};

var spyOnMethod = function spyOnMethod(object) {
  return function (methodName) {
    if (!(object[methodName] && object[methodName].isSinonProxy)) {
      sinon.spy(object, methodName);
    }
  };
};

var copyAndSpyOnMethod = function copyAndSpyOnMethod(object, source) {
  return function (methodName) {
    if (source[methodName].isSinonProxy) {
      object[methodName] = source[methodName];
    } else {
      object[methodName] = sinon.spy(source[methodName]);
    }
  };
};

var getStubConstructorProperties = function getStubConstructorProperties(Target) {
  return {
    SourceConstructor: function SourceConstructor() {},
    processMethodOfInstance: setMethodToStub,
    getInstanceMethodNameSource: function getInstanceMethodNameSource() {
      return Target.prototype;
    },
    processMethodOfConstructor: function processMethodOfConstructor(TheConstructor) {
      return setMethodToStub(TheConstructor);
    },
    addMethodsKey: 'withMethods',
    configureMethodOfInstance: setMethodToStubWithParams
  };
};

var getSpyConstructorProperties = function getSpyConstructorProperties(Target) {
  return {
    SourceConstructor: Target,
    processMethodOfInstance: spyOnMethod,
    getInstanceMethodNameSource: function getInstanceMethodNameSource(instance) {
      return instance;
    },
    processMethodOfConstructor: function processMethodOfConstructor(TheConstructor) {
      return copyAndSpyOnMethod(TheConstructor, Target);
    },
    addMethodsKey: 'withStubs',
    configureMethodOfInstance: stubMethodWithParams
  };
};

function getMethodStubsHandler(methodParams) {
  var result = {};

  methodParams.forEach(setMethodToStubWithParams(result));
  return result;
}

var getStubConstructor = getStubOrSpyConstructor(getStubConstructorProperties);

var getSpyConstructor = getStubOrSpyConstructor(getSpyConstructorProperties);

var getMethodStubs = fluentArguments.createFunc(getMethodStubsHandler);

var returning = fluentArguments.createArg({
  args: [ARG_RETURN_VAL],
  extendsPrevious: true
});

var returningThis = fluentArguments.createArg({
  extra: { returnThis: true },
  extendsPrevious: true
});

exports.getStubConstructor = getStubConstructor;
exports.getSpyConstructor = getSpyConstructor;
exports.getMethodStubs = getMethodStubs;
exports.returning = returning;
exports.returningThis = returningThis;
